# -*- coding: utf-8 -*-
"""BuffonNedle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uCuivGJJNHPd4APHMXfgaClxLU0AVZur
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

# 試行回数 N(1000000000 以上クラッシュ), 線と線の間隔 d, 棒の長さ l(l > d)
N = 10000
d = 0.2
l = 0.1

# 線から針の中心までの距離 x(0 <= x <= d/2)
x = np.random.rand(N) * d / 2

# N個以上の単位円内にある点を作る
while True:
    # 単位円と長さ１の正方形の面積比より、出た単位円内にある期待値の1.3倍乱数を生成
    # 単位円内にあった数がNより小さければ繰り返し
    v = np.random.rand(int(N / (np.pi / 4) * 1.3), 2)
    # plt.scatter(v[:N, 0], v[:N, 1], marker=',')
    # 原点からの距離 radius
    radius = np.sqrt(np.sum(v ** 2, axis=1))
    # 単位円内かどうかのフラグ変数
    flag = (radius <= 1) & (radius != 0)
    v = v[flag, :]
    radius = radius[flag]
    if v.size >= N:
        break
v = v[:N, :]
# plt.scatter(v[:, 0], v[:, 1], marker='.')
radius = radius[:N]
v.shape, radius.shape

# 交わっている本数
# sin(theta) = v[1](y座標) / radius
n = np.sum(x <= (l / 2) * (v[:, 1] / radius))

"""$$error = \left|\frac{pi-np.pi}{np.pi}\right|$$"""

pi = 2 * l * N / (d * n)
print('n: {}\nN: {}'.format(n, N))
print('-' * 20)
print('pi   :{:.16}'.format(pi))
print('np.pi: {:.16}'.format(np.pi))
# 相対誤差
error = abs((pi - np.pi) / np.pi * 100)
print('error = {:.16}%'.format(error))

